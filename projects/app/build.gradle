plugins {
    id 'java-library'
    id 'application'
    id 'com.google.cloud.tools.jib' version '3.3.1'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

description "HoloDB standalone app"

ext.mainClass = 'hu.webarticum.holodb.app.launch.HolodbServerMain'

sourceSets {
    lab {
        compileClasspath += sourceSets.main.runtimeClasspath
        runtimeClasspath += sourceSets.main.runtimeClasspath
    }
}

configurations {
    labImplementation.extendsFrom implementation
    labRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    implementation project(':config')
    implementation project(':core')
    implementation project(':regex')
    implementation project(':spi')
    implementation project(':storage')
    implementation project(':values')
    implementation "hu.webarticum.miniconnect.api:lang:${miniConnectApiVersion}"
    implementation "hu.webarticum.miniconnect.api:lang-jackson:${miniConnectApiVersion}"
    implementation "hu.webarticum.miniconnect.api:api:${miniConnectApiVersion}"
    implementation "hu.webarticum.miniconnect:messenger:${miniConnectVersion}"
    implementation "hu.webarticum.miniconnect:record:${miniConnectVersion}"
    implementation "hu.webarticum.miniconnect:server:${miniConnectVersion}"
    implementation "hu.webarticum.minibase:engine:${miniBaseVersion}"
    
    implementation 'com.github.mifmif:generex:1.0.2'
    implementation 'com.fasterxml.jackson.core:jackson-core:2.13.3'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.13.3'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.13.3'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.13.3'
}

application {
    mainClass = project.ext.mainClass
}

jib {
    to {
        image = 'miniconnect/holodb'
        tags = [version, 'latest']
        auth {
            username = findProperty('dockerHubUsername') ?: ''
            password = findProperty('dockerHubPassword') ?: ''
        }
    }
    container {
        ports = ['3430']
        args = ['/app/config.yaml']
        mainClass = project.ext.mainClass
    }
}

ext.graalDockerName = 'miniconnect/holodb-graal'
ext.graalDockerPlatforms = [

    // these are supported by the normal native-image-edition docker (while the musl version is not multi-platform):
    'linux/amd64',
    'linux/arm64',
    
    /*
    'linux/arm64/v8',
    'linux/arm/v7',
    'linux/386',
    'linux/ppc64le',
    'linux/s390x',*/
]

task graalDockerBuild(type: Exec) {
    dependsOn shadowJar
    workingDir = projectDir
    commandLine(
        'docker', 'build',
        '-t', "${graalDockerName}:latest",
        '-f', 'Dockerfile.graal',
        '.',
    )
}

task graalDockerBuildMultiplatform(type: Exec) {
    dependsOn shadowJar
    workingDir = projectDir
    commandLine(
        'docker', 'buildx', 'build',
        '--platform', graalDockerPlatforms.join(','),
        '-t', "${graalDockerName}:latest",
        '-f', 'Dockerfile.graal',
        '.',
    )
}

task graalDockerExtractBinaries {
    doLast {
        def versionStr = project.version ?: "SNAPSHOT"
        def outputDir = file("${buildDir}/native-image/bin")
        outputDir.mkdirs()
        graalDockerPlatforms.each { platformName ->
            def platformTag = platformName.replaceAll('/', '_')
            def imageName = "${graalDockerName}:latest-${platformTag}"
            def outputFileName = "holodb-${versionStr}-${platformTag}"
            def outputPath = new File(outputDir, outputFileName).absolutePath
            println "Extract native executable for platform '${platformName}' to ${outputPath}"
            def containerIdOutput = new ByteArrayOutputStream()
            exec {
                commandLine(
                    'docker', 'buildx', 'build',
                    '--platform', platformName,
                    '-t', "${graalDockerName}:latest-${platformTag}",
                    '--load',
                    '-f', 'Dockerfile.graal',
                    '.',
                )
            }
            exec {
                commandLine 'docker', 'create', '--platform', platformName, imageName
                standardOutput = containerIdOutput
            }
            def containerId = containerIdOutput.toString().trim()
            if (containerId.isEmpty()) {
                throw new GradleException("Failed to create container for platform: ${platformName}")
            }
            exec { commandLine 'docker', 'cp', "${containerId}:/app/app", outputPath }
            exec { commandLine 'docker', 'rm', containerId }
            exec { commandLine 'docker', 'image', 'rm', imageName }
        }
    }
}
